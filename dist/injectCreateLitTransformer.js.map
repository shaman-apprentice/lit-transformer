{"version":3,"sources":["webpack://createLitTransformer/webpack/bootstrap","webpack://createLitTransformer/./src/full-configured-lit-transformer.js","webpack://createLitTransformer/./src/helper/dataHelper.js","webpack://createLitTransformer/./src/helper/isMustacheFalsy.js","webpack://createLitTransformer/./src/lit-transformer.js","webpack://createLitTransformer/./src/transformers/comment.js","webpack://createLitTransformer/./src/transformers/customDelimiter.js","webpack://createLitTransformer/./src/transformers/invertedSection.js","webpack://createLitTransformer/./src/transformers/section.js","webpack://createLitTransformer/./src/transformers/transformVariable.js","webpack://createLitTransformer/./src/transformers/unsafeVariable.js"],"names":[],"mappings":"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","file":"injectCreateLitTransformer.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/full-configured-lit-transformer.js\");\n","import createTransform from './lit-transformer.js'\nimport transformVariable from './transformers/transformVariable.js'\nimport unsafeVariableTransformer from './transformers/unsafeVariable.js'\nimport sectionTransformer from './transformers/section.js'\nimport invertedSectionTransformer from './transformers/invertedSection.js'\nimport commentTransformer from './transformers/comment.js'\nimport customDelimiterTransformer from './transformers/customDelimiter.js'\n\nexport default (html, unsafeHTML) =>\n  createTransform({\n    html,\n    delimiter: { start: '{{', end: '}}' },\n    transformVariable,\n    transformers: {\n      unsafeVariable: unsafeVariableTransformer(unsafeHTML),\n      section: sectionTransformer(),\n      invertedSection: invertedSectionTransformer(),\n      comment: commentTransformer(),\n      customDelimiterTransformer: customDelimiterTransformer(),\n    },\n  })","export function ctx2Value(ctx, key) {\n  return key.split('.').reduce((acc, key) => key ? acc[key] : acc, ctx)\n}","export function isMustacheFalsy(value) {\n  return [null, undefined, false, 0, NaN, '']\n    .some(falsy => falsy === value)\n    || (value.length && value.length === 0)\n}","/** \n * @param {object} config = {\n *  html: lit-html.html,\n *  delimiter: { start: '{{', end: '}}' },\n *  transformers: { // note that transformVariable is not here, so that it is always the last one\n *    name: {\n *      test: (str, config) => bool,\n *      transform: (str, config) => ({\n *        remainingTmplStr: str,\n *        staticParts: [ str ],\n *        insertionPoint: (ctx) => lit-html.TemplateResult,\n *      }),\n *    },\n *  },\n *  transformVariable, \n * }\n * @returns {function} strTemplate => ctx => lit-html.TemplateResult\n */\nexport default config => template => transform(template, config)\n\nexport function transform(tmpl2Parse, config) {\n  const staticParts = []\n  const insertionPoints = []\n\n  let remainingTmplStr = tmpl2Parse\n  let startIndexOfIP\n  while (0 <= (startIndexOfIP = remainingTmplStr.indexOf(config.delimiter.start))) {\n    staticParts.push(remainingTmplStr.substring(0, startIndexOfIP))\n    remainingTmplStr = remainingTmplStr.substring(startIndexOfIP + config.delimiter.start.length)\n\n    const transform = getTransform(remainingTmplStr, config)\n    const transformResult = transform(remainingTmplStr, config)\n\n    // a template must become smaller with each transformation - if not there was probably a start tag without a closing tag\n    if (transformResult.remainingTmplStr.length + config.delimiter.end.length >= remainingTmplStr.length)\n      throw new Error(`'${tmpl2Parse}' is not a valid template - got stuck at '${remainingTmplStr}'`)\n\n    remainingTmplStr = transformResult.remainingTmplStr\n    insertionPoints.push(transformResult.insertionPoint)\n  }\n\n  staticParts.push(remainingTmplStr)\n\n  return ctx =>\n    config.html(staticParts, ...insertionPoints.map(iP => iP(ctx)))\n}\n\n\nfunction getTransform(remainingTmplStr, config) {\n  const transformer = Object.values(config.transformers).find(t => t.test(remainingTmplStr, config))\n  return transformer\n    ? transformer.transform\n    : config.transformVariable\n}","export default () => ({\n  test: remainingTmplStr => remainingTmplStr[0] === '!',\n  transform: (remainingTmplStr, { delimiter }) => ({\n    remainingTmplStr: remainingTmplStr.substring(remainingTmplStr.indexOf(delimiter.end) + delimiter.end.length),\n    insertionPoint: ctx => '',\n  })\n})","import { transform } from './transformVariable.js'\n\nexport default () => ({\n  test: remainingTmplStr => remainingTmplStr[0] === '=',\n  transform: (remainingTmplStr, config) => {\n    const originalEndDeliLength = config.delimiter.end.length\n    const indexOfEndTag = remainingTmplStr.indexOf('=' + config.delimiter.end)\n    const innerTmpl = remainingTmplStr.substring(1, indexOfEndTag)\n    const newDelis = innerTmpl.split(' ')\n\n    config.delimiter.start = newDelis[0]\n    config.delimiter.end = newDelis[1]\n    \n    return {\n      remainingTmplStr: remainingTmplStr.substring(indexOfEndTag + 1 + originalEndDeliLength),\n      insertionPoint: ctx => '',  \n    }\n  }\n})","import { ctx2Value } from '../helper/dataHelper.js'\nimport { isMustacheFalsy } from '../helper/isMustacheFalsy.js'\n\nexport default () => ({\n  test: remainingTmplStr => remainingTmplStr[0] === '^',\n  transform: (remainingTmplStr, { delimiter }) => {\n    const indexOfStartTagEnd = remainingTmplStr.indexOf(delimiter.end)\n    const dataKey = remainingTmplStr.substring(1, indexOfStartTagEnd)\n    const endTag = delimiter.start + '/' + dataKey + delimiter.end\n    const indexOfEndTagStart = remainingTmplStr.indexOf(endTag)\n    const innerStr = remainingTmplStr.substring(indexOfStartTagEnd + delimiter.start.length, indexOfEndTagStart)\n\n    return {\n      remainingTmplStr: remainingTmplStr.substring(indexOfEndTagStart + endTag.length),\n      insertionPoint: ctx => {\n        const dataValue = ctx2Value(ctx, dataKey)\n\n        return isMustacheFalsy(dataValue)\n          ? innerStr\n          : ''\n      },\n    }\n  }\n})","import { ctx2Value } from '../helper/dataHelper.js'\nimport { isMustacheFalsy } from '../helper/isMustacheFalsy.js'\nimport { transform } from '../lit-transformer.js'\n\n/** Note, unlike within mustache functions as data values are not supported for the time being */\nexport default () => ({\n  test: remainingTmplStr => remainingTmplStr[0] === '#',\n  transform: (remainingTmplStr, config) => {\n    const indexOfStartTagEnd = remainingTmplStr.indexOf(config.delimiter.end)\n    const dataKey = remainingTmplStr.substring(1, indexOfStartTagEnd)\n    const endTag = config.delimiter.start + '/' + dataKey + config.delimiter.end\n    const indexOfEndTagStart = remainingTmplStr.indexOf(endTag)\n    const innerTmpl = remainingTmplStr.substring(indexOfStartTagEnd + config.delimiter.start.length, indexOfEndTagStart)\n    const transformedInnerTmpl = transform(innerTmpl, config)\n\n    return {\n      remainingTmplStr: remainingTmplStr.substring(indexOfEndTagStart + endTag.length),\n      insertionPoint: ctx => {\n        const sectionData = ctx2Value(ctx, dataKey)\n        \n        if (isMustacheFalsy(sectionData))\n          return '';\n\n        return sectionData.map(innerCtx => transformedInnerTmpl(innerCtx))\n      }\n    }\n  }\n})","import { ctx2Value } from '../helper/dataHelper.js'\n\nexport default (remainingTmplStr, { delimiter }) => {\n  const indexOfEndDelimiter = remainingTmplStr.indexOf(delimiter.end)\n  const dataKey = remainingTmplStr.substring(0, indexOfEndDelimiter)\n  return {\n    remainingTmplStr: remainingTmplStr.substring(indexOfEndDelimiter + delimiter.end.length),\n    insertionPoint: ctx => ctx2Value(ctx, dataKey)\n  }\n}","import { ctx2Value } from '../helper/dataHelper.js'\n\n/** Note, this is unsafe to use, because the rendered output could be any JavaScript! */\nexport default unsafeHTML => ({\n  test: remainingTmplStr => remainingTmplStr[0] === '{',\n  transform: (remainingTmplStr, { delimiter }) => {\n    const indexOfEndDelimiter = remainingTmplStr.indexOf('}' + delimiter.end)\n    const dataKey = remainingTmplStr.substring(1, indexOfEndDelimiter)\n    return {\n      remainingTmplStr: remainingTmplStr.substring(indexOfEndDelimiter + 1 + delimiter.end.length),\n      insertionPoint: ctx => unsafeHTML(ctx2Value(ctx, dataKey)),\n    }\n  }\n})"],"sourceRoot":""}